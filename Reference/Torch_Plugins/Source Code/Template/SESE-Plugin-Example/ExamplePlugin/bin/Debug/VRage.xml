<?xml version="1.0"?>
<doc>
    <assembly>
        <name>VRage</name>
    </assembly>
    <members>
        <member name="T:VRage.Animations.AnimationClip">
            <summary>
            An animation clip is a set of keyframes with associated bones.
            </summary>
        </member>
        <member name="F:VRage.Animations.AnimationClip.bones">
            <summary>
            The bones for this animation
            </summary>
        </member>
        <member name="F:VRage.Animations.AnimationClip.Name">
            <summary>
            Name of the animation clip
            </summary>
        </member>
        <member name="F:VRage.Animations.AnimationClip.Duration">
            <summary>
            Duration of the animation clip
            </summary>
        </member>
        <member name="P:VRage.Animations.AnimationClip.Bones">
            <summary>
            The bones for this animation clip with their keyframes
            </summary>
        </member>
        <member name="T:VRage.Animations.AnimationClip.Keyframe">
            <summary>
            An Keyframe is a rotation and translation for a moment in time.
            It would be easy to extend this to include scaling as well.
            </summary>
        </member>
        <member name="T:VRage.Animations.AnimationClip.Bone">
            <summary>
            Keyframes are grouped per bone for an animation clip
            </summary>
        </member>
        <member name="F:VRage.Animations.AnimationClip.Bone.m_name">
            <summary>
            Each bone has a name so we can associate it with a runtime model
            </summary>
        </member>
        <member name="F:VRage.Animations.AnimationClip.Bone.m_keyframes">
            <summary>
            The keyframes for this bone
            </summary>
        </member>
        <member name="P:VRage.Animations.AnimationClip.Bone.Name">
            <summary>
            The bone name for these keyframes
            </summary>
        </member>
        <member name="P:VRage.Animations.AnimationClip.Bone.Keyframes">
            <summary>
            The keyframes for this bone
            </summary>
        </member>
        <member name="T:VRage.Animations.ModelAnimations">
            <summary>
            Class that contains additional information attached to the model and
            shared with the runtime.
            </summary>
        </member>
        <member name="F:VRage.Animations.ModelAnimations.skeleton">
            <summary>
            The bone indices for the skeleton associated with any
            skinned model.
            </summary>
        </member>
        <member name="F:VRage.Animations.ModelAnimations.clips">
            <summary>
            Any associated animation clips
            </summary>
        </member>
        <member name="P:VRage.Animations.ModelAnimations.Skeleton">
            <summary>
            The bone indices for the skeleton associated with any
            skinned model.
            </summary>
        </member>
        <member name="P:VRage.Animations.ModelAnimations.Clips">
            <summary>
            Animation clips associated with this model
            </summary>
        </member>
        <member name="M:VRage.Animations.IMyConstProperty.EditorGetValue">
            <summary>
            Warning, this does allocation, use only in editor!
            </summary>
        </member>
        <member name="M:VRage.Animations.IMyAnimatedProperty.EditorSetKey(System.Int32,System.Single,System.Object)">
            <summary>
            Warning this will do allocations, use only in editor!
            </summary>
        </member>
        <member name="M:VRage.Animations.IMyAnimatedProperty.EditorGetKey(System.Int32,System.Single@,System.Object@)">
            <summary>
            Warning this will do allocations, use only in editor!
            </summary>
        </member>
        <member name="T:VRage.Animations.MyAnimationController">
            <summary>
            Animation controller contains and drives skeletal animations.
            It also serves as an abstraction layer, hiding low/level classes.
            </summary>
        </member>
        <member name="T:VRage.Animations.MyAnimationStateMachine">
            <summary>
            Animation state machine selects the animation to match current state.
            When it finds valid transition to some next state, transition is performed automatically.
            </summary>
        </member>
        <member name="T:VRage.Generics.MyStateMachine">
            <summary>
            Implementation of generic state machine. Inherit from this class to create your own state machine.
            Transitions are performed automatically on each update (if conditions of transition are fulfilled).
            </summary>
        </member>
        <member name="T:VRage.Animations.MyAnimationStateMachineNode">
            <summary>
            Animation state machine node is a representation of one state inside MyAnimationStateMachine.
            </summary>
        </member>
        <member name="T:VRage.Generics.MyStateMachineNode">
            <summary>
            Node of the state machine.
            </summary>
        </member>
        <member name="T:VRage.Animations.MyAnimationStateMachineTransition">
            <summary>
            Description of transition to another state (MyAnimationStateMachineNode) in the state machine (MyAnimationStateMachine).
            </summary>
        </member>
        <member name="T:VRage.Generics.MyStateMachineTransition">
            <summary>
            Definition of transition to some node.
            </summary>
        </member>
        <member name="T:VRage.Animations.MyAnimationTreeNode">
            <summary>
            Interface representing one node in animation tree.
            </summary>
        </member>
        <member name="T:VRage.Animations.MyAnimationUpdateData">
            <summary>
            Helper structure passed as an parameter during computation of current pose.
            </summary>
        </member>
        <member name="T:VRage.Animations.MyAnimationVariableStorage">
            <summary>
            Key-value storage of float values, other types are implicitly converted.
            </summary>
        </member>
        <member name="T:VRage.Generics.IMyVariableStorage`1">
            <summary>
            Interface of variable storage (key-value principle).
            </summary>
        </member>
        <member name="T:VRage.Animations.MyCharacterBone">
            <summary>
            Bones in this model are represented by this class, which
            allows a bone to have more detail associatd with it.
            
            This class allows you to manipulate the local coordinate system
            for objects by changing the scaling, translation, and rotation.
            These are indepenent of the bind transformation originally supplied
            for the model. So, the actual transformation for a bone is
            the product of the:
            
            Scaling
            Bind scaling (scaling removed from the bind transform)
            Rotation
            Translation
            Bind Transformation
            Parent Absolute Transformation
            
            </summary>
        </member>
        <member name="F:VRage.Animations.MyCharacterBone.m_parent">
            <summary>
            Any parent for this bone
            </summary>
        </member>
        <member name="F:VRage.Animations.MyCharacterBone.m_bindTransform">
            <summary>
            The bind transform is the transform for this bone
            as loaded from the original model. It's the base pose.
            I do remove any scaling, though.
            </summary>
        </member>
        <member name="F:VRage.Animations.MyCharacterBone.m_translation">
            <summary>
            Any translation applied to the bone
            </summary>
        </member>
        <member name="F:VRage.Animations.MyCharacterBone.m_rotation">
            <summary>
            Any rotation applied to the bone
            </summary>
        </member>
        <member name="F:VRage.Animations.MyCharacterBone.m_transform">
            <summary>
            computed bone transform
            </summary>
        </member>
        <member name="F:VRage.Animations.MyCharacterBone.m_changed">
            <summary>
            indicates whether bone needs recalculation
            </summary>
        </member>
        <member name="F:VRage.Animations.MyCharacterBone.m_hierarchyUpdate">
            <summary>
            indicates whether hierarchy of bones is updating
            </summary>
        </member>
        <member name="F:VRage.Animations.MyCharacterBone.Name">
            <summary>
            The bone name
            </summary>
        </member>
        <member name="F:VRage.Animations.MyCharacterBone.AbsoluteTransform">
            <summary>
            The bone absolute transform
            </summary>
        </member>
        <member name="M:VRage.Animations.MyCharacterBone.#ctor(System.String,VRageMath.Matrix,VRage.Animations.MyCharacterBone)">
            <summary>
            Constructor for a bone object
            </summary>
            <param name="name">The name of the bone</param>
            <param name="bindTransform">The initial bind transform for the bone</param>
            <param name="parent">A parent for this bone</param>
        </member>
        <member name="M:VRage.Animations.MyCharacterBone.ComputeAbsoluteTransform">
            <summary>
            Compute the absolute transformation for this bone.
            </summary>
        </member>
        <member name="M:VRage.Animations.MyCharacterBone.SetCompleteTransform(VRageMath.Vector3@,VRageMath.Quaternion@,System.Single)">
            <summary>
            This sets the rotation and translation such that the
            rotation times the translation times the bind after set
            equals this matrix. This is used to set animation values.
            </summary>
            <param name="m">A matrix include translation and rotation</param>
        </member>
        <member name="M:VRage.Animations.MyCharacterBone.GetAbsoluteRigTransform">
            <summary>
            Returns bone's rig absolute transform - including transforms of all parent bones
            </summary>
            <returns></returns>
        </member>
        <member name="P:VRage.Animations.MyCharacterBone.BindTransform">
            <summary>
            The bone bind transform
            </summary>
        </member>
        <member name="P:VRage.Animations.MyCharacterBone.SkinTransform">
            <summary>
            Inverse of absolute bind transform for skinnning
            </summary>
        </member>
        <member name="P:VRage.Animations.MyCharacterBone.Rotation">
            <summary>
            Bone rotation
            </summary>
        </member>
        <member name="P:VRage.Animations.MyCharacterBone.Translation">
            <summary>
            Any translations
            </summary>
        </member>
        <member name="P:VRage.Animations.MyCharacterBone.Parent">
            <summary>
            The parent bone or null for the root bone
            </summary>
        </member>
        <member name="M:VRage.Audio.IMyAudio.ApplyEffect(VRage.Audio.IMySourceVoice,VRage.Utils.MyStringHash,VRage.Audio.MyCueId[],System.Nullable{System.Single})">
            <summary>
            Creates effect on input emitter
            </summary>
            <param name="input">Emitter to work with</param>
            <param name="effect"></param>
            <param name="cueIds">additional cues if effect mixes them (ie. crossfade)</param>
            <returns>effect output sound</returns>
        </member>
        <member name="T:VRage.Data.Audio.MyCurveType">
            <summary>
            Enumerator of available curve types
            </summary>
        </member>
        <member name="M:System.BitCompressionExtensions.ReadQuaternionNormCompressed(VRage.Library.Collections.BitStream)">
            <summary>
            Serializes normalized quaternion into 29 bits
            </summary>
        </member>
        <member name="M:System.BitCompressionExtensions.WriteQuaternionNormCompressed(VRage.Library.Collections.BitStream,VRageMath.Quaternion)">
            <summary>
            Serializes normalized quaternion into 29 bits
            </summary>
        </member>
        <member name="M:System.BitCompressionExtensions.SerializeNormCompressed(VRage.Library.Collections.BitStream,VRageMath.Quaternion@)">
            <summary>
            Serializes normalized quaternion into 29 bits
            </summary>
        </member>
        <member name="M:System.BitCompressionExtensions.ReadQuaternionNormCompressedIdentity(VRage.Library.Collections.BitStream)">
            <summary>
            Serializes normalized quaternion into 1 or 30 bits
            </summary>
        </member>
        <member name="M:System.BitCompressionExtensions.WriteQuaternionNormCompressedIdentity(VRage.Library.Collections.BitStream,VRageMath.Quaternion)">
            <summary>
            Serializes normalized quaternion into 1 or 30 bits
            </summary>
        </member>
        <member name="M:System.BitCompressionExtensions.SerializeNormCompressedIdentity(VRage.Library.Collections.BitStream,VRageMath.Quaternion@)">
            <summary>
            Serializes normalized quaternion into 1 or 30 bits
            </summary>
        </member>
        <member name="T:VRage.WoodFractureSettings.Rotation">
            How to rotate the splitting geometry
        </member>
        <member name="T:VRage.Generics.IMyCondition">
            <summary>
            Interface of totally generic condition.
            </summary>
        </member>
        <member name="M:VRage.Generics.IMyCondition.Evaluate">
            <summary>
            Evaluate the condition, it can be true/false.
            </summary>
        </member>
        <member name="T:VRage.Generics.MyCachingDynamicObjectsPool`2">
            This class provides similar functionality to MyDynamicObjectsPool with the addition of caching facilities.
            
            The cache is intended to be used for objects that once allocated either perform expensive computations
            or allocate a lot of memory *and* that may be needed again after disposed in the same state.
        </member>
        <member name="M:VRage.Generics.MyCachingDynamicObjectsPool`2.Deallocate(`1)">
            Deallocate object without key.
            
            Object is disposed be callee.
        </member>
        <member name="M:VRage.Generics.MyCachingDynamicObjectsPool`2.Deallocate(`0,`1)">
            Deallocate object with key.
            
            Object is cached and disposed if necessary.
        </member>
        <member name="M:VRage.Generics.MyCachingDynamicObjectsPool`2.TryAllocateCached(`0,`1@)">
            Allocate an object that may be cached.
            
            Returns true if the object was found in the cache and false otherwise.
        </member>
        <member name="T:VRage.Generics.StateMachine.MyCondition`1">
            <summary>
            Implementation of generic condition.
            </summary>
        </member>
        <member name="T:VRage.Generics.MyStateMachineTransitionWithStart">
            <summary>
            Pair holding transition and its starting node.
            </summary>
        </member>
        <member name="M:VRage.Import.ModelAutoRebuild.IsModelActual(System.String,System.String,System.String,System.String)">
            <summary>
            Checks whether that model file was build with current sources files. If current sources of this model - FBX, XML, HKT etc. were changed, this returns false.
            </summary>
            <param name="modelFile"></param>
            <returns>true - if data hashes of source files are valid </returns>
            <returns>false - if data has been changed</returns>
        </member>
        <member name="M:VRage.Import.MyModelExporter.#ctor(System.String)">
            <summary>
            c-tor
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="M:VRage.Import.MyModelExporter.#ctor">
            <summary>
            c-tor
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="M:VRage.Import.MyModelExporter.Dispose">
            <summary>
            Close
            </summary>
        </member>
        <member name="M:VRage.Import.MyModelExporter.WriteTag(System.String)">
            <summary>
            WriteTag
            </summary>
            <param name="tagName"></param>
        </member>
        <member name="M:VRage.Import.MyModelExporter.WriteVector(VRageMath.Vector2)">
            <summary>
            WriteVector2
            </summary>
            <param name="vct"></param>
        </member>
        <member name="M:VRage.Import.MyModelExporter.WriteVector(VRageMath.Vector3)">
            <summary>
            WriteVector3
            </summary>
            <param name="vct"></param>
        </member>
        <member name="M:VRage.Import.MyModelExporter.WriteVector(VRageMath.Vector4)">
            <summary>
            WriteVector4
            </summary>
            <param name="vct"></param>
        </member>
        <member name="M:VRage.Import.MyModelExporter.WriteMatrix(VRageMath.Matrix)">
            <summary>
            WriteMatrix
            </summary>
            <param name="matrix"></param>
        </member>
        <member name="M:VRage.Import.MyModelExporter.WriteVector(VRageMath.Vector2I)">
            <summary>
            WriteVector2
            </summary>
            <param name="vct"></param>
        </member>
        <member name="M:VRage.Import.MyModelExporter.WriteVector(VRageMath.Vector3I)">
            <summary>
            WriteVector3
            </summary>
            <param name="vct"></param>
        </member>
        <member name="M:VRage.Import.MyModelExporter.WriteVector(VRageMath.Vector4I)">
            <summary>
            WriteVector4
            </summary>
            <param name="vct"></param>
        </member>
        <member name="M:VRage.Import.MyModelExporter.WriteByte4(VRageMath.PackedVector.Byte4)">
            <summary>
            Write Byte4
            </summary>
        </member>
        <member name="M:VRage.Import.MyModelExporter.ExportData(System.String,VRageMath.Vector3[])">
            <summary>
            ExportData
            </summary>
            <param name="tagName"></param>
            <param name="vctArray"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelExporter.ExportData(System.String,VRageMath.Matrix[])">
            <summary>
            ExportData
            </summary>
            <param name="tagName"></param>
            <param name="vctArray"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelExporter.ExportData(System.String,VRageMath.Vector2[])">
            <summary>
            ExportData
            </summary>
            <param name="tagName"></param>
            <param name="vctArray"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelExporter.ExportData(System.String,VRageMath.Vector4[])">
            <summary>
            ExportData
            </summary>
            <param name="tagName"></param>
            <param name="strArr"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelExporter.ExportData(System.String,System.String[])">
            <summary>
            ExportData
            </summary>
            <param name="tagName"></param>
            <param name="strArr"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelExporter.ExportData(System.String,System.Int32[])">
            <summary>
            ExportData
            </summary>
            <param name="tagName"></param>
            <param name="strArr"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelExporter.ExportData(System.String,System.Byte[])">
            <summary>
            ExportData
            </summary>
            <param name="tagName"></param>
            <param name="strArr"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelExporter.ExportData(System.String,VRage.Import.MyModelInfo)">
            <summary>
            ExportData
            </summary>
            <param name="tagName"></param>
            <param name="strArr"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelExporter.ExportData(System.String,VRageMath.BoundingBox)">
            <summary>
            ExportData
            </summary>
            <param name="tagName"></param>
            <param name="strArr"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelExporter.ExportData(System.String,VRageMath.BoundingSphere)">
            <summary>
            ExportData
            </summary>
            <param name="tagName"></param>
            <param name="strArr"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelExporter.ExportData(System.String,System.Collections.Generic.Dictionary{System.String,VRageMath.Matrix})">
            <summary>
            ExportData
            </summary>
            <param name="tagName"></param>
            <param name="dict"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelExporter.ExportData(System.String,System.Collections.Generic.List{VRage.Import.MyMeshPartInfo})">
            <summary>
            ExportData
            </summary>
            <param name="tagName"></param>
            <param name="dict"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelExporter.ExportData(System.String,System.Collections.Generic.Dictionary{System.String,VRage.Import.MyModelDummy})">
            <summary>
            ExportData
            </summary>
            <param name="tagName"></param>
            <param name="dict"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelExporter.ExportFloat(System.String,System.Single)">
            <summary>
            ExportFloat
            </summary>
            <param name="tagName"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelExporter.ExportBool(System.String,System.Boolean)">
            <summary>
            ExportFloat
            </summary>
            <param name="tagName"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelExporter.WriteQuaternion(VRageMath.Quaternion)">
            <summary>
            WriteQuaternion
            </summary>
            <param name="vct"></param>
        </member>
        <member name="M:VRage.Input.MyControl.GetAnalogState">
            <summary>
            Return the analog state between 0 (not pressed at all) and 1 (fully pressed).
            If a digital button is mapped to an analog control, it can return only 0 or 1.
            </summary>
        </member>
        <member name="M:VRage.Input.MyControl.ToString">
            <summary>
            Causes allocation. Creates single string with list of assigned controls.
            </summary>
        </member>
        <member name="M:VRage.Input.MyControl.ToStringBuilder(System.String)">
            <summary>
            Causes allocation. Creates single StringBuilder with list of assigned controls. Caller
            takes ownership of returned StringBuilder (it is not stored internally).
            </summary>
        </member>
        <member name="T:VRage.Input.MyKeys">
            <summary>
            Enumeration for virtual keys.
            </summary>
        </member>
        <member name="M:VRage.MyCompilationSymbols.IsProfilerAttached">
            <summary>
            This is reliable, enforced by .NET documentation.
            Without this environment variable, CLR won't attach profiler.
            </summary>
        </member>
        <member name="T:VRage.MyDeltaTransform">
            <summary>
            Transform structure for delta-transforms.
            </summary>
        </member>
        <member name="T:VRage.NetProfiler">
            <summary>
            Shortcut class for network profiler.
            </summary>
        </member>
        <member name="M:VRage.NetProfiler.Begin(System.String,System.Int32,System.String,System.Int32,System.String)">
            <summary>
            Starts net profiling block.
            </summary>
        </member>
        <member name="M:VRage.NetProfiler.End(System.Nullable{System.Single},System.Single,System.String,System.String,System.String,System.String,System.Int32,System.String)">
            <summary>
            End net profiling block.
            </summary>
            <param name="bytesTransfered">Specify number of bytes transferred or null to automatically calculate number of bytes from inner blocks.</param>
            <param name="customValue">You can put any number here.</param>
            <param name="customValueFormat">This is formatting string how the number will be written on screen, use something like: 'MyNumber: {0} foos/s'</param>
        </member>
        <member name="T:VRage.Noise.MyModule">
            <summary>
            High quality noise module that combines properties of Value noise and gradient noise.
            Value noise is used as input for gradient function. This leads to no artifacts or zero values at integer points.
            It's so called Value-Gradient noise.
            </summary>
        </member>
        <member name="P:VRageRender.MyRenderMessageBase.MessageClass">
            <summary>
            Get message class
            </summary>
        </member>
        <member name="P:VRageRender.MyRenderMessageBase.MessageType">
            <summary>
            Gets message type
            </summary>
        </member>
        <member name="T:VRageRender.MyRenderMessageSwitchRenderSettings">
            <summary>
            1 at the end is naming convention from DX, saying this is newer version (for Dx11 render).
            </summary>
        </member>
        <member name="M:VRage.IMyBufferedInputSource.SwapBufferedTextInput(System.Collections.Generic.List{System.Char}@)">
            <summary>
            Swaps internal buffer with the one passed as argument. This swapping operation
            must be implemented in a thread safe manner. Buffer passed into the function will
            replaced by the internal buffer and returned in the same variable.
            </summary>
        </member>
        <member name="M:VRage.IMyRenderWindow.OnModeChanged(VRageRender.MyWindowModeEnum,System.Int32,System.Int32)">
            <summary>
            Called by render when display mode has changed
            </summary>
        </member>
        <member name="P:VRage.IMyRenderWindow.DrawEnabled">
            <summary>
            True when Present on device should be called (e.g. window not minimized)
            </summary>
        </member>
        <member name="P:VRage.IMyRenderWindow.Handle">
            <summary>
            Target window handle
            </summary>
        </member>
        <member name="M:VRage.MyGameRenderComponent.Start(VRage.Library.Utils.MyGameTimer,VRage.InitHandler,System.Nullable{VRageRender.MyRenderDeviceSettings},VRageRender.MyRenderQualityEnum)">
            <summary>
            Creates and starts render thread
            </summary>
        </member>
        <member name="M:VRage.MyGameRenderComponent.Stop">
            <summary>
            Stops and clears render thread
            </summary>
        </member>
        <member name="T:VRage.InitHandler">
            <summary>
            Initializes window on render thread and returns it's handle of window/control where to draw
            </summary>
        </member>
        <member name="M:VRage.MyRenderThread.Exit">
            <summary>
            Signals the thread to exit and waits until it does so
            </summary>
        </member>
        <member name="M:VRage.Generics.MySparseGrid`2.ClearCells">
            <summary>
            Clears cells, but keep them preallocated
            </summary>
        </member>
        <member name="T:VRage.Generics.MyDynamicObjectPool`1">
            <summary>
            Dynamic object pool. It's allocate new instance when necessary.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:VRage.Generics.MyObjectsPool`1.AllocateOrCreate(`0@)">
            <summary>
            Returns true when new item was allocated
            </summary>
        </member>
        <member name="T:VRage.Generics.MyWeightDictionary`1">
            <summary>
            Contains items of any type. Each item has weight (float value).
            Allows to get item based on weight.
            </summary>
            <typeparam name="T">The item type</typeparam>
        </member>
        <member name="M:VRage.Generics.MyWeightDictionary`1.#ctor(System.Collections.Generic.Dictionary{`0,System.Single})">
            <summary>
            Initializes a new instance of the MyWeightDictionary class.
            </summary>
            <param name="data">Dictionary with items and weights.</param>
        </member>
        <member name="M:VRage.Generics.MyWeightDictionary`1.GetSum">
            <summary>
            Gets sum of weights.
            </summary>
            <returns>The sum of all weights.</returns>
        </member>
        <member name="M:VRage.Generics.MyWeightDictionary`1.GetItemByWeightNormalized(System.Single)">
            <summary>
            Gets item based on weight.
            </summary>
            <param name="weightNormalized">Weight, value from 0 to 1.</param>
            <returns>The item.</returns>
        </member>
        <member name="M:VRage.Generics.MyWeightDictionary`1.GetItemByWeight(System.Single)">
            <summary>
            Gets item based on weight.
            </summary>
            <param name="weight">Weight, value from 0 to sum.</param>
            <returns></returns>
        </member>
        <member name="M:VRage.Generics.MyWeightDictionary`1.GetRandomItem(System.Random)">
            <summary>
            Gets random item based on weight.
            </summary>
            <returns>The item.</returns>
        </member>
        <member name="T:VRage.Import.MyMaterialDescriptor">
            <summary>
            material params for export
            </summary>
        </member>
        <member name="F:VRage.Import.MyMaterialDescriptor.ExtraData">
            <summary>
            Extra data (animation of holos)
            </summary>
        </member>
        <member name="M:VRage.Import.MyMaterialDescriptor.#ctor(System.String)">
            <summary>
            c-tor
            </summary>
            <param name="materialName"></param>
        </member>
        <member name="M:VRage.Import.MyMaterialDescriptor.Write(System.IO.BinaryWriter)">
            <summary>
            Write to binary file
            </summary>
            <param name="writer"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelImporter.ReadVector3(System.IO.BinaryReader)">
            <summary>
            Read Vector34
            </summary>
        </member>
        <member name="M:VRage.Import.MyModelImporter.ReadHalfVector4(System.IO.BinaryReader)">
            <summary>
            Read HalfVector4
            </summary>
        </member>
        <member name="M:VRage.Import.MyModelImporter.ReadHalfVector2(System.IO.BinaryReader)">
            <summary>
            Read HalfVector2
            </summary>
        </member>
        <member name="M:VRage.Import.MyModelImporter.ReadByte4(System.IO.BinaryReader)">
            <summary>
            Read Byte4
            </summary>
        </member>
        <member name="M:VRage.Import.MyModelImporter.ImportVector3(System.IO.BinaryReader)">
            <summary>
            ImportVector3
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelImporter.ImportVector4(System.IO.BinaryReader)">
            <summary>
            ImportVector4
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelImporter.ImportQuaternion(System.IO.BinaryReader)">
            <summary>
            ImportQuaternion
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelImporter.ImportVector4Int(System.IO.BinaryReader)">
            <summary>
            ImportVector4Int
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelImporter.ImportVector3Int(System.IO.BinaryReader)">
            <summary>
            ImportVector3Int
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelImporter.ImportVector2(System.IO.BinaryReader)">
            <summary>
            ImportVector2
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelImporter.ReadArrayOfHalfVector4(System.IO.BinaryReader)">
            <summary>
            Read array of HalfVector4
            </summary>
        </member>
        <member name="M:VRage.Import.MyModelImporter.ReadArrayOfByte4(System.IO.BinaryReader)">
            <summary>
            Read array of Byte4
            </summary>
        </member>
        <member name="M:VRage.Import.MyModelImporter.ReadArrayOfHalfVector2(System.IO.BinaryReader)">
            <summary>
            Read array of HalfVector2
            </summary>
        </member>
        <member name="M:VRage.Import.MyModelImporter.ReadArrayOfVector3(System.IO.BinaryReader)">
            <summary>
            ReadArrayOfVector3
            </summary>
            <param name="br"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelImporter.ReadArrayOfVector4(System.IO.BinaryReader)">
            <summary>
            ReadArrayOfVector4
            </summary>
            <param name="br"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelImporter.ReadArrayOfVector4Int(System.IO.BinaryReader)">
            <summary>
            ReadArrayOfVector4
            </summary>
            <param name="br"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelImporter.ReadArrayOfVector3Int(System.IO.BinaryReader)">
            <summary>
            ReadArrayOfVector3I
            </summary>
            <param name="br"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelImporter.ReadArrayOfVector2(System.IO.BinaryReader)">
            <summary>
            ReadArrayOfVector2
            </summary>
            <param name="br"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelImporter.ReadArrayOfString(System.IO.BinaryReader)">
            <summary>
            ReadArrayOfString
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelImporter.ReadBoundingBox(System.IO.BinaryReader)">
            <summary>
            ReadBoundingBox
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelImporter.ReadBoundingSphere(System.IO.BinaryReader)">
            <summary>
            ReadBoundingSphere
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelImporter.ReadMatrix(System.IO.BinaryReader)">
            <summary>
            ReadMatrix
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelImporter.ReadMeshParts(System.IO.BinaryReader,System.Int32)">
            <summary>
            ReadMeshParts
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelImporter.ReadDummies(System.IO.BinaryReader)">
            <summary>
            ReadDummies
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelImporter.ReadArrayOfInt(System.IO.BinaryReader)">
            <summary>
            ReadArrayOfInt
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Import.MyModelImporter.LinearKeyframeReduction(System.Collections.Generic.LinkedList{VRage.Animations.AnimationClip.Keyframe},System.Single,System.Single)">
            <summary>
            This function filters out keyframes that can be approximated well with 
            linear interpolation.
            </summary>
            <param name="keyframes"></param>
        </member>
        <member name="F:VRageRender.MyRenderMessageType.Draw">
            <summary>
            Draw message, skipped when processing multiple updates (only handled in last update before draw)
            Draw sprite, debug draw...
            </summary>
        </member>
        <member name="F:VRageRender.MyRenderMessageType.StateChangeOnce">
            <summary>
            State change which can be applied only once, not applied when rendering same frame second time or more
            Add render object, remove render object...
            </summary>
        </member>
        <member name="F:VRageRender.MyRenderMessageType.StateChangeEvery">
            <summary>
            State change which must be applied every time, even when drawing same frame multiple times
            Move render object, other interpolation messages
            </summary>
        </member>
        <member name="T:VRageRender.MyRenderMessageUpdateRenderEnvironment">
            <summary>
            The difference between environment and RenderSettings is that environment are game play values,
            on the other hand render settings are render internal/debugging values
            </summary>
        </member>
        <member name="T:VRage.Noise.Patterns.MyCylinders">
            <summary>
            Noise that outputs concentric cylinders.
            Each cylinder extends infinitely along the y axis.
            </summary>
        </member>
        <member name="T:VRage.Noise.Patterns.MyRing">
            <summary>
            Noise that outputs dounut-like ring
            </summary>
        </member>
        <member name="T:VRage.Noise.Models.MyCylinder">
            <summary>
            Maps the output of a module onto a cylinder.
            </summary>
        </member>
        <member name="T:VRage.Noise.Models.MySphere">
            <summary>
            Maps the output of a module onto a sphere.
            </summary>
        </member>
        <member name="T:VRage.Noise.Modifiers.MyCurve">
            <summary>
            Maps the output value from a source module onto an arbitrary function curve.
            </summary>
        </member>
        <member name="T:VRage.Noise.Modifiers.MyExponent">
            <summary>
            Maps the output value from a source module onto an exponential curve.
            </summary>
        </member>
        <member name="T:VRage.Noise.Modifiers.MyAbs">
            <summary>
            Outputs the absolute value of the output value from a source module.
            </summary>
        </member>
        <member name="T:VRage.Noise.Modifiers.MyInvert">
            <summary>
            Inverts the output value from a source module.
            </summary>
        </member>
        <member name="T:VRage.Noise.Modifiers.MyClamp">
            <summary>
            Clamps the output value from a source module to a range of values.
            </summary>
        </member>
        <member name="T:VRage.Noise.MyModuleFast">
            <summary>
            Faster version of MyModule.
            This time we do not compute the gradient position directly but we're using gradient table lookup via permutation table.
            This leads to more 'grid' result as the local min and max (like in Value noise) are always appearing at integer points.
            </summary>
        </member>
        <member name="T:VRage.Noise.Patterns.MySpheres">
            <summary>
            Noise that outputs concentric spheres.
            </summary>
        </member>
        <member name="T:VRage.MyMultipleEnabledEnum">
            <summary>
            Enumeration describing Enabled state of multiple objects.
            </summary>
        </member>
        <member name="T:VRage.ProfilerShort">
            <summary>
            Helper class, "shortcuts" to profiler
            </summary>
        </member>
        <member name="T:VRageRender.Profiler.MyRenderProfiler">
            <summary>
            Provides profiling capability
            </summary>
            <remarks>
            Non-locking way of render profiler is used. Each thread has it's own profiler is ThreadStatic variable.
            Data for each profiling block are of two kinds: Immediate (current frame being profiled) and History (previous finished frames)
            Start/End locking is not necessary, because Start/Stop uses only immediate data and nothing else uses it at the moment.
            Commit is only other place which uses Immediate data, but it must be called from same thead, no racing condition.
            Draw and Commit both uses History data, and both can be called from different thread, so there's lock.
            This way everything runs with no waiting, unless Draw obtains lock in which case Commit wait for Draw to finish (Start/End is still exact).
            
            For threads which does not call commit (background workers, parallel tasks), mechanism which calls commit automatically after each top level End should be added.
            This way each task will be one "frame" on display
            </remarks>
        </member>
        <member name="M:VRageRender.Profiler.MyRenderProfiler.CreateProfiler(System.String,System.String,System.Boolean)">
            <summary>
            Creates new profiler which can be used to profile anything (e.g. network stats).
            </summary>
        </member>
        <member name="P:VRageRender.Profiler.MyRenderProfiler.ProfilerVisible">
            <summary>
            Returns true when profiler is visible.
            </summary>
        </member>
        <member name="F:VRageRender.Profiler.MyDrawArea.m_index">
            <summary>
            Index 0, 1, 2, 3, 4, 5...
            Makes range 1, 1.5, 2, 3, 4, 6, 8, 12, 24, 32, 48, 64...
            Negative index is supported as well.
            </summary>
        </member>
        <member name="M:VRageRender.Profiler.MyDrawArea.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Initializes draw area.
            </summary>
            <param name="yRange">Range of y axis, will be rounded to 2^n or 2^n * 1.5</param>
        </member>
        <member name="P:VRageRender.Profiler.MyRenderProfilerRendering.ViewportSize">
            <summary>
            Returns viewport size in pixels
            </summary>
        </member>
        <member name="T:VRageRender.MyRenderStats">
            <summary>
            Draws statistics
            </summary>
        </member>
        <member name="F:VRageRender.MyFont.REPLACEMENT_CHARACTER">
            <summary>
            Replacement character shown when we don't have something in our texture.
            Normally, this would be \uFFFD, but BMFontGen refuses to generate it, so I put its glyph at \u25A1 (empty square)
            </summary>
        </member>
        <member name="F:VRageRender.MyFont.Spacing">
            <summary>
            This is artificial spacing in between two characters (in pixels).
            Using it we can make spaces wider or narrower
            </summary>
        </member>
        <member name="F:VRageRender.MyFont.KernEnabled">
            <summary>
            Enable / disable kerning of adjacent character pairs.
            </summary>
        </member>
        <member name="F:VRageRender.MyFont.Depth">
            <summary>
            The depth at which to draw the font
            </summary>
        </member>
        <member name="M:VRageRender.MyFont.#ctor(System.String,System.Int32)">
            <summary>
            Create a new font from the info in the specified font descriptor (XML) file
            </summary>
        </member>
        <member name="M:VRageRender.MyFont.LoadFontXML(System.Xml.XmlNodeList)">
            <summary>
            Load the font data from an XML font descriptor file
            </summary>
            <param name="xnl">XML node list containing the entire font descriptor file</param>
        </member>
        <member name="M:VRageRender.MyFont.LoadFontXML_font(System.Xml.XmlNodeList)">
            <summary>
            Load the data from the "font" node
            </summary>
            <param name="xnl">XML node list containing the "font" node's children</param>
        </member>
        <member name="M:VRageRender.MyFont.LoadFontXML_bitmaps(System.Xml.XmlNodeList)">
            <summary>
            Load the data from the "bitmaps" node
            </summary>
            <param name="xnl">XML node list containing the "bitmaps" node's children</param>
        </member>
        <member name="M:VRageRender.MyFont.LoadFontXML_glyphs(System.Xml.XmlNodeList)">
            <summary>
            Load the data from the "glyphs" node
            </summary>
            <param name="xnl">XML node list containing the "glyphs" node's children</param>
        </member>
        <member name="M:VRageRender.MyFont.LoadFontXML_kernpairs(System.Xml.XmlNodeList)">
            <summary>
            Load the data from the "kernpairs" node
            </summary>
            <param name="xnl">XML node list containing the "kernpairs" node's children</param>
        </member>
        <member name="M:VRageRender.MyFont.GetXMLAttribute(System.Xml.XmlNode,System.String)">
            <summary>
            Get the XML attribute value
            </summary>
            <param name="n">XML node</param>
            <param name="strAttr">Attribute name</param>
            <returns>Attribute value, or the empty string if the attribute doesn't exist</returns>
        </member>
        <member name="P:VRageRender.MyFont.Baseline">
            <summary>
            Distance from top of font to the baseline
            </summary>
        </member>
        <member name="P:VRageRender.MyFont.LineHeight">
            <summary>
            Distance from top to bottom of the font
            </summary>
        </member>
        <member name="T:VRageRender.MyFont.MyGlyphInfo">
            <summary>
             Info for each glyph in the font - where to find the glyph image and other properties
            </summary>
        </member>
        <member name="T:VRageRender.MyFont.MyBitmapInfo">
            <summary>
            Info for each font bitmap
            </summary>
        </member>
        <member name="F:VRageRender.MyRenderQualityProfile.ShadowCascadeLODTreshold">
            <summary>
            Determines last index of cascade, which will use LOD0 objects. Lower cascade index means
            closer cascade to camera. Ie. 0 means all cascaded will use LOD1 models (worst shadow quality),
            5 means best quality, because all cascades will use LOD0 objects (we have 4 cascades currently);
            </summary>
        </member>
        <member name="F:VRageRender.MyRenderQualityProfile.ShadowMapCascadeSize">
            <summary>
            Size in pixels for one shadow map cascade (of 4 total). Be carefull, we are limited by 8192 in texture size on PC.
            </summary>
        </member>
        <member name="F:VRageRender.MyRenderConstants.MAX_GPU_OCCLUSION_QUERY_DISTANCE">
            <summary>
            Maximum distance for which a light uses occlusion an occlusion query.
            </summary>
        </member>
        <member name="M:VRageRender.MyRenderConstants.SwitchRenderQuality(VRageRender.MyRenderQualityEnum)">
            <summary>
            This should be called only from LoadContent
            </summary>
        </member>
        <member name="T:VRageRender.MyMessagePool">
            <summary>
            TODO: This should use some better sync, it could introduce delays with current state
            1) Use spin lock
            2) Lock only queue, not whole dictionary
            3) Test count first and when it's insufficient, create new message, both should be safe to do out of any lock
            4) Custom consumer/producer non-locking (except resize) queue could be better (maybe overkill)
            </summary>
        </member>
        <member name="T:VRageRender.RenderFlags">
            <summary>
            Entity flags.
            </summary>
        </member>
        <member name="F:VRageRender.RenderFlags.SkipIfTooSmall">
            <summary>
            Skip the object in render if detected that it is too small
            </summary>
        </member>
        <member name="F:VRageRender.RenderFlags.NeedsResolveCastShadow">
            <summary>
            Needs resolve cast shadows flag (done by parallel raycast to sun)
            </summary>
        </member>
        <member name="F:VRageRender.RenderFlags.FastCastShadowResolve">
            <summary>
            Casts only one raycast to determine shadow casting
            </summary>
        </member>
        <member name="F:VRageRender.RenderFlags.CastShadows">
            <summary>
            Tells if this object should cast shadows
            </summary>
        </member>
        <member name="F:VRageRender.RenderFlags.Visible">
            <summary>
            Specifies whether draw this entity or not.
            </summary>
        </member>
        <member name="F:VRageRender.RenderFlags.DrawOutsideViewDistance">
            <summary>
            Specifies whether this entity should be drawn even when it is outside the set view distance
            </summary>
        </member>
        <member name="F:VRageRender.RenderFlags.Near">
            <summary>
            Specifies whether entity is "near", near entities are cockpit and weapons, these entities are rendered in special way
            </summary>
        </member>
        <member name="F:VRageRender.RenderFlags.UseCustomDrawMatrix">
            <summary>
            Tells if this object should use PlayerHeadMatrix as matrix for draw
            </summary>
        </member>
        <member name="F:VRageRender.RenderFlags.ShadowLodBox">
            <summary>
            Use local AABB box for shadow LOD
            </summary>
        </member>
        <member name="F:VRageRender.RenderFlags.NoBackFaceCulling">
            <summary>
            No culling of back faces
            </summary>
        </member>
        <member name="F:VRageRender.RenderFlags.OffsetInVertexShader">
            <summary>
            Offset the vertices a little bit in the vertex shader to fix Z-fighting
            </summary>
        </member>
        <member name="T:VRageRender.LightTypeEnum">
            <summary>
            Light type, flags, could be combined
            </summary>
        </member>
        <member name="F:VRageRender.Lights.MyGlareTypeEnum.Normal">
            <summary>
            This is the glare that is dependent on occlusion queries.
            Physically, this phenomenon originates in the lens.
            </summary>
        </member>
        <member name="F:VRageRender.Lights.MyGlareTypeEnum.Distant">
            <summary>
            This is the glare that you see even if the light itself is occluded.
            It gives the impression of scattering in a medium (like fog).
            </summary>
        </member>
        <member name="F:VRageRender.Lights.MyGlareTypeEnum.Directional">
            <summary>
            Like normal, but gets dimmed with camera vs. reflector angle
            </summary>
        </member>
        <member name="T:VRageRender.Textures.TextureQuality">
            <summary>
            Reresent loading quality for textures.
            This works only for dds textures with mipmaps. Other textures will retains their original properties.
            </summary>
        </member>
        <member name="F:VRageRender.Textures.TextureQuality.Full">
            <summary>
            Full quality.
            </summary>
        </member>
        <member name="F:VRageRender.Textures.TextureQuality.Half">
            <summary>
            1/2 quality.
            </summary>
        </member>
        <member name="F:VRageRender.Textures.TextureQuality.OneFourth">
            <summary>
            1/4 quality
            </summary>
        </member>
        <member name="F:VRageRender.Textures.TextureQuality.OneEighth">
            <summary>
            1/8 quality
            </summary>
        </member>
        <member name="F:VRageRender.Textures.TextureQuality.OneSixteenth">
            <summary>
            1/16 quality
            </summary>
        </member>
        <member name="T:VRageRender.MyRenderSettings">
            <summary>
            Settings for whole render. To make settings per draw, use RenderSetup
            </summary>
        </member>
        <member name="T:VRageRender.MyAntialiasingMode">
            <summary>
            VRage.Render11 only.
            </summary>
        </member>
        <member name="T:VRageRender.MyShadowsQuality">
            <summary>
            VRage.Render11 only.
            </summary>
        </member>
        <member name="T:VRageRender.MyTextureQuality">
            <summary>
            VRage.Render11 only.
            </summary>
        </member>
        <member name="T:VRageRender.MyTextureAnisoFiltering">
            <summary>
            VRage.Render11 only.
            </summary>
        </member>
        <member name="T:VRageRender.MyRenderSettings1">
            <summary>
            Naming convention from DX. Newer version for Dx11 render.
            Put only settings that player can control (either directly or indirectly) using options here.
            Don't put debug crap here!
            </summary>
        </member>
        <member name="P:VRageRender.MyVertexFormatVoxelSingleData2.MaterialAlphaIndex">
            <summary>
            For multimaterial vertex only
            0, 1 or 2, indicates what material is on this vertex
            </summary>
        </member>
        <member name="P:VRageRender.MyVertexFormatVoxelSingleData.Material">
            <summary>
            For multimaterial vertex only
            0, 1 or 2, indicates what material is on this vertex
            </summary>
        </member>
        <member name="M:VRageRender.MyCubeInstanceData.ResetBones">
            <summary>
            Resets bones to zero and disables skinning
            </summary>
        </member>
        <member name="P:VRageRender.MyCubeInstanceData.Translation">
            <summary>
            Gets translation, faster than getting local matrix
            </summary>
        </member>
        <member name="T:VRageRender.SpriteScissorStack">
            <summary>
            Stores stack of scissor rectangles where top rectangle has already
            been cut using all the rectangles below it, so that only one
            rectangle is checked during scissor test.
            </summary>
        </member>
        <member name="M:VRageRender.SpriteScissorStack.Cut(VRageMath.RectangleF@,VRageMath.RectangleF@)">
            <summary>
            Cuts the destination rectangle using top of the scissor stack.
            Source rectangle is modified using scaled change of destination
            as well.
            </summary>
        </member>
        <member name="T:VRageRender.MySharedData">
            <summary>
            Data shared between render and update
            </summary>
        </member>
        <member name="M:VRageRender.MySharedData.BeforeUpdate">
            <summary>
            Refresh data from render (visible objects, render messages)
            </summary>
        </member>
        <member name="M:VRageRender.MyUpdateData.CommitUpdateFrame">
            <summary>
            Commits current frame as atomic operation and prepares new frame
            </summary>
        </member>
        <member name="M:VRageRender.MyUpdateData.GetRenderFrame(System.Boolean@)">
            <summary>
            Gets next frame for rendering, can return null in case there's nothing for rendering (no update frame submitted).
            When isPreFrame is true, don't handle draw messages, just process update messages and call method again.
            Pre frame must release messages and must be returned.
            Final frame is kept unmodified in queue, in case of slower update, so we can interpolate and draw frame again.
            </summary>
        </member>
        <member name="M:VRageRender.MyUpdateData.ReturnPreFrame(VRageRender.MyUpdateFrame)">
            <summary>
            PreFrame must be empty in this place
            </summary>
        </member>
        <member name="T:VRageRender.MyUpdateFrame">
            <summary>
            Contains data produced by update frame, sent to render in thread-safe manner
            </summary>
        </member>
        <member name="T:VRageRender.VideoState">
            <summary>
            Describes the state of a video player
            </summary>
        </member>
        <member name="P:VRageRender.IMyRender.IsSupported">
            <summary>
            Must be possible to query during startup before render thread and window is created.
            </summary>
        </member>
        <member name="M:VRageRender.MyRenderProxy.ChangeModel(System.UInt32,System.Int32,System.String,System.Boolean)">
            <summary>
            New model should have similar size to previous model because of prunning structure recalculation
            </summary>
            <param name="id"></param>
            <param name="LOD"></param>
            <param name="model"></param>
            <param name="useForShadow"></param>
        </member>
        <member name="T:VRageRender.Graphics.SpriteEffects">
            <summary>
            Defines sprite mirroring options.
            </summary>
            <remarks>
            Description is taken from original XNA <a href='http://msdn.microsoft.com/en-us/library/VRageMath.graphics.spriteeffects.aspx'>SpriteEffects</a> class.
            </remarks>
        </member>
        <member name="F:VRageRender.Graphics.SpriteEffects.None">
            <summary>
            No rotations specified.
            </summary>
        </member>
        <member name="F:VRageRender.Graphics.SpriteEffects.FlipHorizontally">
            <summary>
            Rotate 180 degrees around the Y axis before rendering.
            </summary>
        </member>
        <member name="F:VRageRender.Graphics.SpriteEffects.FlipVertically">
            <summary>
            Rotate 180 degrees around the X axis before rendering.
            </summary>
        </member>
        <member name="F:VRageRender.Graphics.SpriteEffects.FlipBoth">
            <summary>
            Rotate 180 degress around both the X and Y axis before rendering.
            </summary>
        </member>
        <member name="T:VRage.Network.BlockingAttribute">
            <summary>
            Indicates that event will be blocking all other events.
            </summary>
        </member>
        <member name="M:VRage.Network.BlockingAttribute.#ctor">
            <summary>
            Creates attribute that indicates that event will be blocking all other events until this is resolved.
            </summary>
        </member>
        <member name="T:VRage.Network.BroadcastExceptAttribute">
            <summary>
            Client method. Decorated method is be called by server on all clients (except the one who invoked it on server or the one specified in RaiseEvent...when called from server).
            Clients always trust server and does not perform any validation.
            When used together with Server attribute, server validates data, invokes the method on server and then sends it to all clients except the client who invoked it on server.
            </summary>
        </member>
        <member name="T:VRage.Network.BroadcastAttribute">
            <summary>
            Client method. Decorated method is be called by server on all clients.
            Clients always trust server and does not perform any validation.
            When used together with Server attribute, server validates data, invokes the method on server and then sends it to all clients.
            </summary>
        </member>
        <member name="T:VRage.Network.ClientAttribute">
            <summary>
            Client method. Decorated method is be called by server on client.
            Clients always trust server and does not perform any validation.
            When used together with Server attribute, server validates data, invokes the method on server and then sends it to client who invoked it on server.
            </summary>
        </member>
        <member name="T:VRage.Network.EndpointId">
            <summary>
            Id of network endpoint, opaque struct, internal value should not be accessed outside VRage.Network.
            EndpointId is not guid and can change when client reconnects to server.
            Internally it's SteamId or RakNetGUID.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyBandwidthLimits.GetLimit(VRage.Network.StateGroupEnum)">
            <summary>
            Gets current limit for group (how many bits can be written per frame).
            Return zero when there's no limit.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyBandwidthLimits.SetLimit(VRage.Network.StateGroupEnum,System.Int32)">
            <summary>
            Sets limit for group (how many bits can be written per frame).
            It's ensured that at least one item is sent every frame.
            Setting limit to zero disables limit.
            </summary>
        </member>
        <member name="M:VRage.Network.MyClientInfo.GetPriority(VRage.Network.IMyReplicable)">
            <summary>
            Gets priority of different replicable.
            E.g. can be used to get priority of grid when calling GetPriority on cube block.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyReplicables.Add(VRage.Network.IMyReplicable,VRage.Network.IMyReplicable@)">
            <summary>
            Sets or resets replicable (updates child status and parent).
            Returns true if replicable is root, otherwise false.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyReplicables.RefreshChildrenHierarchy(VRage.Network.IMyReplicable)">
            <summary>
            Refreshes all children.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyReplicables.Refresh(VRage.Network.IMyReplicable)">
            <summary>
            Refreshes replicable, updates it's child status and parent.
            Returns true if replicable is root.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyReplicables.Remove(VRage.Network.IMyReplicable)">
            <summary>
            Removes replicable, children should be already removed
            </summary>
        </member>
        <member name="M:VRage.Replication.MyReplicables.RemoveHierarchy(VRage.Network.IMyReplicable)">
            <summary>
            Removes replicable with all children, children of children, etc.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyReplicables.RemoveChildren(VRage.Network.IMyReplicable)">
            <summary>
            Removes all children of replicable.
            Children of children should be already removed!
            </summary>
        </member>
        <member name="T:VRage.Network.NotReplicableAttribute">
            <summary>
            Marks class which should be never replicated.
            </summary>
        </member>
        <member name="M:System.Extensions.FindStateGroup``1(VRage.Network.IMyReplicable)">
            <summary>
            Finds state group of specified type.
            Returns null when group of specified type not found.
            </summary>
        </member>
        <member name="T:VRage.Network.IMyEventProxy">
            <summary>
            Interface which only marks class as event owner.
            Object itself must be replicated in network to allow raising events.
            If you considering to add this to object, it's probably wrong and you should use static events in most cases.
            This is commonly implemented only by entities which has it's external replicable.
            </summary>
        </member>
        <member name="T:VRage.Network.IMyEventOwner">
            <summary>
            Common interface for IMyNetObject and IMyEventProxy used to raise events.
            Base interface for classes passed as event instance.
            Custom implementations not supported.
            </summary>
        </member>
        <member name="T:VRage.Network.IMyNetObject">
            <summary>
            Base interface for networked object.
            Derived interfaces are so far IMyReplicable and IMyStateGroup.
            </summary>
        </member>
        <member name="P:VRage.Network.IMyProxyTarget.Target">
            <summary>
            Gets target object.
            </summary>
        </member>
        <member name="M:VRage.Network.IMyReplicable.GetDependency">
            <summary>
            Gets dependency which must be replicated first.
            </summary>
        </member>
        <member name="M:VRage.Network.IMyReplicable.GetPriority(VRage.Network.MyClientInfo)">
            <summary>
            Gets priority related to client.
            When priority is lower than zero, it means the object is not relevant for client.
            Default priority is 1.0f.
            </summary>
        </member>
        <member name="M:VRage.Network.IMyReplicable.OnSave(VRage.Library.Collections.BitStream)">
            <summary>
            Serializes object for replication to client.
            </summary>
        </member>
        <member name="M:VRage.Network.IMyReplicable.OnLoad(VRage.Library.Collections.BitStream,System.Action{System.Boolean})">
            <summary>
            Client deserializes object and adds it to proper collection (e.g. MyEntities).
            Loading done handler can be called synchronously or asynchronously (but always from Update thread).
            </summary>
        </member>
        <member name="M:VRage.Network.IMyReplicable.OnLoadBegin(VRage.Library.Collections.BitStream,System.Action{System.Boolean})">
            <summary>
            Client deserializes object and adds it to proper collection (e.g. MyEntities).
            Loading done handler can be called synchronously or asynchronously (but always from Update thread).
            </summary>
        </member>
        <member name="M:VRage.Network.IMyReplicable.OnDestroy">
            <summary>
            Called on client when server destroyed this replicable.
            </summary>
        </member>
        <member name="M:VRage.Network.IMyReplicable.GetStateGroups(System.Collections.Generic.List{VRage.Network.IMyStateGroup})">
            <summary>
            Returns state groups for replicable in a list.
            This method can has to return objects in same order every time (e.g. first terminal, second physics etc).
            It does not have to return same instances every time.
            </summary>
        </member>
        <member name="P:VRage.Network.IMyReplicable.IsChild">
            <summary>
            Child replicables are strongly dependent on parent.
            When parent is replicated, children are replicated, priority is never checked for children.
            Dependency can change during replicable runtime, IsChild can not.
            </summary>
        </member>
        <member name="M:VRage.Network.IMyStateGroup.CreateClientData(VRage.Network.MyClientStateBase)">
            <summary>
            Called on server new clients starts replicating this group.
            </summary>
        </member>
        <member name="M:VRage.Network.IMyStateGroup.DestroyClientData(VRage.Network.MyClientStateBase)">
            <summary>
            Called on server when client stops replicating this group.
            </summary>
        </member>
        <member name="M:VRage.Network.IMyStateGroup.ClientUpdate">
            <summary>
            Update method called on client.
            </summary>
        </member>
        <member name="M:VRage.Network.IMyStateGroup.Destroy">
            <summary>
            Called when state group is being destroyed.
            </summary>
        </member>
        <member name="M:VRage.Network.IMyStateGroup.GetGroupPriority(System.Int32,VRage.Network.MyClientInfo)">
            <summary>
            Gets priority related to client.
            When priority is lower than zero, it means the object is not relevant for client.
            Default priority is 1.0f.
            </summary>
            <param name="frameCountWithoutSync">How long (in update frame count) has client not received sync of this state group.</param>
            <param name="forClient">Client for whom is the priority get.</param>
        </member>
        <member name="M:VRage.Network.IMyStateGroup.Serialize(VRage.Library.Collections.BitStream,VRage.Network.MyClientStateBase,System.Byte,System.Int32)">
            <summary>
            (De)serializes group state or it's diff for client.
            When writing, you can write beyond maxBitPosition, but message won't be sent and ACKs won't be received for it.
            ReplicationServer will detect, that state group written beyond packet size and revert it.
            When nothing written, ReplicationServer will detect that and state group won't receive ACK for that packet id.
            </summary>
            <param name="stream">Stream to write to or read from.</param>
            <param name="forClient">When writing the client which will receive the data. When reading, it's null.</param>
            <param name="packetId">Id of packet in which the data will be sent or from which the data is received.</param>
            <param name="maxBitPosition">Maximum position in bit stream where you can write data, it's inclusive.</param>
        </member>
        <member name="M:VRage.Network.IMyStateGroup.OnAck(VRage.Network.MyClientStateBase,System.Byte,System.Boolean)">
            <summary>
            Called for each packet id sent to client from this state group.
            When ACK received, called immediatelly.
            When several other packets received from client, but some were missing, called for each missing packet.
            </summary>
            <param name="forClient">The client.</param>
            <param name="packetId">Id of the delivered or lost packet.</param>
            <param name="delivered">True when packet was delivered, false when packet is considered lost.</param>
        </member>
        <member name="M:VRage.Replication.MyEventsBuffer.EnqueueEvent(VRage.Library.Collections.BitStream,VRage.Network.NetworkId,VRage.Network.NetworkId,System.UInt32,VRage.Network.EndpointId)">
            <summary>
            Enqueues event that have to be done on target object.
            </summary>
            <param name="stream">Stream with event data.</param>
            <param name="targetObjectId">Object id that is a target of the event.</param>
            <param name="blockingObjectId">Object id that is blocking target to be processed. 'NetworkId.Invalid' if none.</param>
            <param name="eventId">Event id.</param>
            <param name="sender">Endpoint.</param>
        </member>
        <member name="M:VRage.Replication.MyEventsBuffer.EnqueueBarrier(VRage.Network.NetworkId,VRage.Network.NetworkId)">
            <summary>
            Enqueues barrier for an entity that is targeting network object with blocking event. WARNING: Have to be in
            pair with blocking event!
            </summary>
            <param name="targetObjectId">Network object id that will get barrier event.</param>
            <param name="blockingObjectId">Network object that have blocking event.</param>
        </member>
        <member name="M:VRage.Replication.MyEventsBuffer.RemoveEvents(VRage.Network.NetworkId)">
            <summary>
            Removes all events from target id.
            </summary>
            <param name="objectInstance">Target object network id.</param>
        </member>
        <member name="M:VRage.Replication.MyEventsBuffer.TryLiftBarrier(VRage.Network.NetworkId)">
            <summary>
            Tries to lift barrier from target network object. If successfull, removes this barrier from
            target object events queue. Also barrier must be aiming target object id.
            </summary>
            <param name="targetObjectId">Target network object id.</param>
            <returns>True if barrier found on the top of target object events queue. Otherwise false.</returns>
        </member>
        <member name="M:VRage.Replication.MyEventsBuffer.ProcessEvents(VRage.Network.NetworkId,VRage.Replication.MyEventsBuffer.Handler,VRage.Replication.MyEventsBuffer.IsBlockedHandler,VRage.Network.NetworkId)">
            <summary>
            Tries to process events for prarticular object id (network id).
            </summary>
            <param name="targetObjectId">Target object network id.</param>
            <param name="eventHandler">Handler for processing events.</param>
            <param name="isBlockedHandler">Handler for checking if processing of events should be canceled.</param>
            <param name="caller">Parent Network id from which this is called. Set NetworkId.Invalid if no parent.</param>
            <returns>True if all sucessfull.</returns>
        </member>
        <member name="M:VRage.Replication.MyEventsBuffer.ProcessBarrierEvent(VRage.Network.NetworkId,VRage.Replication.MyEventsBuffer.MyBufferedEvent,VRage.Replication.MyEventsBuffer.Handler,VRage.Replication.MyEventsBuffer.IsBlockedHandler)">
            <summary>
            Process barrier event.
            </summary>
            <param name="targetObjectId">Target of the barrier event.</param>
            <param name="eventToProcess">Event to process.</param>
            <param name="eventHandler">Handler for processing event.</param>
            <param name="isBlockedHandler">Handler for checking if processing of events should be canceled.</param>
            <returns>True if success.</returns>
        </member>
        <member name="M:VRage.Replication.MyEventsBuffer.ProcessBlockingEvent(VRage.Network.NetworkId,VRage.Replication.MyEventsBuffer.MyBufferedEvent,VRage.Network.NetworkId,VRage.Replication.MyEventsBuffer.Handler,VRage.Replication.MyEventsBuffer.IsBlockedHandler,System.Collections.Generic.Queue{VRage.Network.NetworkId}@)">
            <summary>
            Process blocking event.
            </summary>
            <param name="targetObjectId">Target object id for which to process.</param>
            <param name="eventToProcess">Event to be processed.</param>
            <param name="caller">Parent Network id from which this is called. Set NetworkId.Invalid if no parent.</param>
            <param name="eventHandler">Handler for processing event.</param>
            <param name="isBlockedHandler">Handler for checking if processing of events should be canceled.</param>
            <param name="postProcessQueue">Queue that should be post processed.</param>
            <returns>True if was success.</returns>
        </member>
        <member name="M:VRage.Replication.MyEventsBuffer.GetEventsBufferStat">
            <summary>
            Gets events buffer statistics.
            </summary>
            <returns>Formatted events buffer statistics.</returns>
        </member>
        <member name="F:VRage.Replication.MyEventsBuffer.MyBufferedEvent.Stream">
            <summary>
            Stream with the event
            </summary>
        </member>
        <member name="F:VRage.Replication.MyEventsBuffer.MyBufferedEvent.TargetObjectId">
            <summary>
            Target object net id of the event.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyEventsBuffer.MyBufferedEvent.BlockingObjectId">
            <summary>
            Object network id that is blocking this event. If 'NetworkId.Invalid' than no blocking object.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyEventsBuffer.MyBufferedEvent.IsBarrier">
            <summary>
            Indicates if this event is a barrier.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyEventsBuffer.MyObjectEventsBuffer.Events">
            <summary>
            Events to be processed for network object.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyEventsBuffer.MyObjectEventsBuffer.IsProcessing">
            <summary>
            Indicates if events are currently processed.
            </summary>
        </member>
        <member name="M:VRage.Network.MyReplicationLayerBase.InvokeLocally``7(VRage.Network.CallSite{``0,``1,``2,``3,``4,``5,``6},``0,``1,``2,``3,``4,``5,``6)">
            <summary>
            Invokes event locally without validation and with empty Sender and ClientData.
            </summary>
        </member>
        <member name="T:VRage.Network.RefreshReplicableAttribute">
            <summary>
            
            </summary>
        </member>
        <member name="T:VRage.Network.MyClientStateBase">
            <summary>
            Base class for game-defined client state.
            It's set of data required by server, sent from client.
            E.g. current client area of interest, context (game, terminal, inventory etc...)
            Abstract class for performance reasons (often casting)
            </summary>
        </member>
        <member name="M:VRage.Network.MyClientStateBase.Serialize(VRage.Library.Collections.BitStream)">
            <summary>
            Serializes state into/from bit stream.
            EndpointId should be ignored.
            </summary>
        </member>
        <member name="P:VRage.Network.MyClientStateBase.EndpointId">
            <summary>
            Client endpoint, don't serialize it in Serialize()
            </summary>
        </member>
        <member name="F:VRage.Network.MyEventContext.Sender">
            <summary>
            Event sender, default(EndpointId) when invoked locally.
            </summary>
        </member>
        <member name="F:VRage.Network.MyEventContext.ClientState">
            <summary>
            Event sender client data, valid only when invoked remotely on server, otherwise null.
            </summary>
        </member>
        <member name="F:VRage.Network.MyEventContext.IsValidationRequired">
            <summary>
            True if validation is required.
            </summary>
        </member>
        <member name="M:VRage.Network.MyPacketQueue.Clear">
            <summary>
            Clears whole queue.
            </summary>
        </member>
        <member name="M:VRage.Network.MyPacketQueue.Enqueue(VRage.Library.Collections.BitStream,System.Single,VRage.Network.EndpointId)">
            <summary>
            Sends message, when broadcasting, recipient is peer who won't receive the message.
            </summary>
        </member>
        <member name="M:VRage.Network.MyPacketQueue.Send(System.Int32)">
            <summary>
            Sends packets in queue, sends no more than maxBytesToSend.
            Returns number of bytes sent.
            </summary>
        </member>
        <member name="P:VRage.Replication.MyReplicableClientData.IsSleeping">
            <summary>
            When replicable is sleeping, it should not receive state updates. But it has to receive events.
            </summary>
        </member>
        <member name="P:VRage.Replication.MyReplicableClientData.HasActiveStateSync">
            <summary>
            Returns true when replicable is not pending and is not sleeping.
            </summary>
        </member>
        <member name="M:VRage.Network.MyReplicationLayer.ReserveFixedIds(System.UInt32)">
            <summary>
            Reserves IDs for fixed objects.
            </summary>
        </member>
        <member name="M:VRage.Network.MyReplicationLayer.AddFixedNetworkObject(System.UInt32,VRage.Network.IMyNetObject)">
            <summary>
            Add network object with fixed ID.
            </summary>
        </member>
        <member name="M:VRage.Network.MyReplicationLayer.GetMultiplayerStat">
            <summary>
            Returns string with current multiplayer status. Use only for debugging.
            </summary>
            <returns>Already formatted string with current multiplayer status.</returns>
        </member>
        <member name="M:VRage.Network.MyReplicationLayer.DispatchEvent(VRage.Library.Collections.BitStream,VRage.Network.CallSite,VRage.Network.EndpointId,VRage.Network.IMyNetObject,System.Single)">
            <summary>
            Called when event is raised locally to send it to other peer(s).
            Return true to invoke event locally.
            </summary>
            <remarks>
            Invoking event locally is important to be done AFTER event is sent to other peers, 
            because invocation can raise another event and order must be preserved.
            Local event invocation is done in optimized way without unnecessary deserialization.
            </remarks>
        </member>
        <member name="M:VRage.Network.MyReplicationLayer.ProcessEvent(VRage.Library.Collections.BitStream,VRage.Network.CallSite,System.Object,VRage.Network.IMyNetObject,VRage.Network.EndpointId)">
            <summary>
            Called when event is received over network.
            Event can be validated, invoked and/or transferred to other peers.
            </summary>
        </member>
        <member name="M:VRage.Network.MyReplicationLayer.Invoke(VRage.Network.CallSite,VRage.Library.Collections.BitStream,System.Object,VRage.Network.EndpointId,VRage.Network.MyClientStateBase,System.Boolean)">
            <summary>
            Reads arguments from stream and invokes event. Returns false when validation failed, otherwise true.
            </summary>
        </member>
        <member name="M:VRage.Network.MyReplicationClient.SetReplicableReady(VRage.Network.NetworkId,VRage.Network.IMyReplicable,System.Boolean)">
            <summary>
            Marks replicable as successfully created, ready to receive events and state groups data.
            </summary>
        </member>
        <member name="M:VRage.Network.MyReplicationClient.IsBlocked(VRage.Network.NetworkId,VRage.Network.NetworkId)">
            <summary>
            Checks if network id is blocked by other network id.
            </summary>
            <param name="networkId">Target network id.</param>
            <param name="blockedNetId">Blocking network id.</param>
            <returns></returns>
        </member>
        <member name="M:VRage.Network.MyReplicationClient.ProcessStateSync(VRage.MyPacket)">
            <summary>
            Processes state sync sent by server.
            </summary>
        </member>
        <member name="F:VRage.Network.MyReplicationServer.m_replicables">
            <summary>
            All replicables on server.
            </summary>
        </member>
        <member name="F:VRage.Network.MyReplicationServer.m_replicableGroups">
            <summary>
            All replicable state groups.
            </summary>
        </member>
        <member name="F:VRage.Network.MyReplicationServer.m_clientStates">
            <summary>
            Network objects and states which are actively replicating to clients.
            </summary>
        </member>
        <member name="F:VRage.Network.MyReplicationServer.m_timeFunc">
            <summary>
            Function which provides current update time
            </summary>
        </member>
        <member name="M:VRage.Network.MyReplicationServer.PauseReplication">
            <summary>
            Stops sending replication create until resumed.
            </summary>
        </member>
        <member name="M:VRage.Network.MyReplicationServer.ForceReplicable(VRage.Network.IMyReplicable,VRage.Network.IMyReplicable)">
            <summary>
            Hack to allow thing like: CreateCharacter, Respawn sent from server
            </summary>
        </member>
        <member name="M:VRage.Network.MyReplicationServer.ForceReplicable(VRage.Network.IMyReplicable,VRage.Network.EndpointId)">
            <summary>
            Hack to allow thing like: CreateCharacter, Respawn sent from server
            </summary>
        </member>
        <member name="M:VRage.Network.MyReplicationServer.ForceEverything(VRage.Network.EndpointId)">
            <summary>
            Sends everything in the world to client. Use with extreme caution!
            </summary>
        </member>
        <member name="M:VRage.Network.MyReplicationServer.ResetForClients(VRage.Network.IMyReplicable)">
            <summary>
            Destroys replicable for all clients (used for testing and debugging).
            </summary>
        </member>
        <member name="M:VRage.Network.MyReplicationServer.IsPreceding(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns true when current packet is closely preceding last packet (is within threshold)
            </summary>
        </member>
        <member name="T:VRage.Network.MySynchronizedTypeInfo">
            <summary>
            Type descriptor for synchronized type.
            </summary>
        </member>
        <member name="M:VRage.Network.MyTypeTable.Serialize(VRage.Library.Collections.BitStream)">
            <summary>
            Serializes id to hash list.
            Server sends the hashlist to client, client reorders type table to same order as server.
            </summary>
        </member>
        <member name="T:VRage.Network.NetworkId">
            <summary>
            Network object identifier. Similar to entity id, but on network.
            Also one entity can have multiple NetworkIds, one main, one for physics sync, one for terminal sync and more.
            Opaque struct, it should not be necessary to internal member outside VRage.Network.
            NetworkId is not persistent and changes with server restart, never store it in persistent storage (saves).
            Internally takes advantage of small numbers.
            </summary>
        </member>
        <member name="T:VRage.Network.ReliableAttribute">
            <summary>
            Event which is sent reliably, use with caution and only when necessary!
            </summary>
        </member>
        <member name="T:VRage.Network.ServerAttribute">
            <summary>
            Server method. Decorated method is be called by client on server or by server locally.
            Server performs validation. Pass null as validation method to perform no validation (not recommended)
            </summary>
        </member>
        <member name="T:VRage.Network.StateGroupEnum">
            <summary>
            State groups, used to limit bandwidth by group.
            </summary>
        </member>
        <member name="P:VRage.Serialization.SerializableDictionary`2.Dictionary">
            <summary>
            Public stuff dictionary.
            </summary>
            <remarks>
            Note the XmlIgnore attribute.
            </remarks>
        </member>
        <member name="P:VRage.Serialization.SerializableDictionary`2.DictionaryEntryProp">
            <summary>
            Property created expressly for the XmlSerializer
            </summary>
            <remarks>
            Note the XML Serialiazation attributes; they control what elements are named when this object is serialized.
            </remarks>
        </member>
        <member name="P:VRage.Serialization.SerializableDictionaryCompat`3.DictionaryEntryProp">
            <summary>
            Property created expressly for the XmlSerializer
            </summary>
            <remarks>
            Note the XML Serialiazation attributes; they control what elements are named when this object is serialized.
            </remarks>
        </member>
        <member name="F:VRage.Serialization.SerializeAttribute.Flags">
            <summary>
            Serialization flags for member itself.
            </summary>
        </member>
        <member name="F:VRage.Serialization.SerializeAttribute.PrimitiveFlags">
            <summary>
            Serialization flags for primitive types, when defined for types, passed down the hierarchy.
            </summary>
        </member>
        <member name="F:VRage.Serialization.SerializeAttribute.FixedLength">
            <summary>
            Length for fixed length arrays, collections and strings.
            </summary>
        </member>
        <member name="F:VRage.Serialization.SerializeAttribute.DynamicSerializerType">
            <summary>
            Type of dynamic resolver.
            </summary>
        </member>
        <member name="F:VRage.Serialization.SerializeAttribute.Kind">
            <summary>
            Kind of attribute, specify Item for collections like list, array or dictionary value, specify Key for dictionary key.
            </summary>
        </member>
        <member name="M:VRage.Serialization.MyMemberSerializer.Clone(System.Object,System.Object)">
            <summary>
            Makes clone of object member.
            </summary>
        </member>
        <member name="M:VRage.Serialization.MyMemberSerializer.Equals(System.Object,System.Object)">
            <summary>
            Tests equality of object members.
            </summary>
        </member>
        <member name="T:VRage.Serialization.MyPrimitiveFlags">
            <summary>
            Primitive flags are passed down the object hierarchy.
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyPrimitiveFlags.None">
            <summary>
            No primitive flags.
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyPrimitiveFlags.Signed">
            <summary>
            Flag which indicates whether primitive is signed.
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyPrimitiveFlags.Normalized">
            <summary>
            Flag which indicates whether primitive is normalized.
            Exact behavior depends on actual type (0..1, -1..1, normalized vector, etc)
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyPrimitiveFlags.Variant">
            <summary>
            Serialize member as unsigned variant (variable length integer, 0-127...1-byte, 127-32767...2-byte, etc)
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyPrimitiveFlags.VariantSigned">
            <summary>
            Serialize member as unsigned signed (-63..64, 1-byte etc, -32767..32768, 2-byte, etc)
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyPrimitiveFlags.Ascii">
            <summary>
            Serialize string in ascii encoding
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyPrimitiveFlags.Utf8">
            <summary>
            Serialize string in UTF8 encoding
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyPrimitiveFlags.FixedPoint8">
            <summary>
            Fixed point 8-bit precision, use with normalized
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyPrimitiveFlags.FixedPoint16">
            <summary>
            Fixed point 16-bit precision, use with normalized
            </summary>
        </member>
        <member name="F:VRage.Serialization.MySerializeInfo.KeyInfo">
            <summary>
            Serialization settings for dictionar key.
            </summary>
        </member>
        <member name="F:VRage.Serialization.MySerializeInfo.ItemInfo">
            <summary>
            Serialization settings for dictionary value or collection / array elements
            </summary>
        </member>
        <member name="M:VRage.Serialization.MySerializer`1.Clone(`0@)">
            <summary>
            In-place clone.
            Primitive and immutable types can implements this as empty method.
            Reference types must create new instance a fill it's members.
            </summary>
        </member>
        <member name="M:VRage.Serialization.MySerializer`1.Equals(`0@,`0@)">
            <summary>
            Tests equality.
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyObjectFlags.None">
            <summary>
            No serialization flags
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyObjectFlags.DefaultZero">
            <summary>
            Do not serialize member when it has default value, null for objects, zeros for structs.
            In binary streams, bit is written to indicate whether object had a value or not.
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyObjectFlags.Nullable">
            <summary>
            Alias to default value.
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyObjectFlags.Dynamic">
            <summary>
            Member can store subclasses of specified type, actual member type will be serialized as well.
            Valid only on class members (not for value types).
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyObjectFlags.DefaultValueOrEmpty">
            <summary>
            Applies only to collections.
            When serializing empty collection (zero element count) it will behave like DefaultValue.
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyObjectFlags.DynamicDefault">
            <summary>
            Same as dynamic, but stores a bit indicating whether serialized type is different from member type or not.
            When it's same, type is not serialized. Usefull when some instances have default type.
            </summary>
        </member>
        <member name="M:VRage.Serialization.MyMemberSerializer`1.Clone(`0@,`0@)">
            <summary>
            Makes clone of object member.
            </summary>
        </member>
        <member name="M:VRage.Serialization.MyMemberSerializer`1.Equals(`0@,`0@)">
            <summary>
            Tests equality of object members.
            </summary>
        </member>
        <member name="M:VRage.SyncExtensions.ValidateNever``1(VRage.Sync{``0})">
            <summary>
            Sets validation handler to always return false.
            </summary>
        </member>
        <member name="M:VRage.SyncExtensions.ValidateRange(VRage.Sync{System.Single},System.Single,System.Single)">
            <summary>
            Sets validate handler to validate that value is in range.
            </summary>
        </member>
        <member name="M:VRage.SyncExtensions.ValidateRange(VRage.Sync{System.Single},System.Func{System.Single},System.Func{System.Single})">
            <summary>
            Sets validate handler to validate that value is in range.
            </summary>
        </member>
        <member name="M:VRage.SyncExtensions.ValidateRange(VRage.Sync{System.Single},System.Func{VRageMath.MyBounds})">
            <summary>
            Sets validate handler to validate that value is withing bounds.
            </summary>
        </member>
        <member name="M:VRage.Library.Sync.SyncHelpers.Compose(System.Object,System.Int32,System.Collections.Generic.List{VRage.SyncBase})">
            <summary>
            Takes objects and creates instances of Sync fields.
            </summary>
        </member>
        <member name="E:VRage.SyncBase.ValueChanged">
            <summary>
            ValueChanged event is raised when value is set locally (settings Value property) or remotely (through deserialization).
            When validation fails, value is not changed and ValueChanged is not raised.
            </summary>
        </member>
        <member name="F:VRage.Sync`1.Validate">
            <summary>
            Validate handler is raised on server after deserialization.
            </summary>
        </member>
        <member name="M:VRage.Sync`1.ValidateAndSet(`0)">
            <summary>
            Validates the value and sets it (when valid).
            </summary>
        </member>
        <member name="T:VRage.Utils.MyDiscreteSampler`1">
            <summary>
            A templated class for sampling from a set of objects with given probabilities. Uses MyDiscreteSampler.
            </summary>
        </member>
        <member name="T:VRage.Utils.MyDiscreteSampler">
            <summary>
            Provides a simple and efficient way of sampling a discrete probability distribution as described in http://www.jstatsoft.org/v11/i03/paper
            Instances can be reused by calling the Prepare method every time you want to change the distribution.
            Sampling a value is O(1), while the storage requirements are O(N), where N is number of possible values
            </summary>
        </member>
        <member name="M:VRage.Utils.MyDiscreteSampler.Prepare(System.Collections.Generic.IEnumerable{System.Single})">
            The list supplied to the method does not have to add up to 1.0f, that's why it's called "densities" instead of "probabilities"
        </member>
        <member name="T:VRage.Utils.MyStringHash">
            <summary>
            Generates string hashes deterministically and crashes on collisions. When used as key for hash tables (Dictionary or HashSet)
            always pass in MyStringHash.Comparer, otherwise lookups will allocate memory! Can be safely used in network but never serialize to disk!
            
            IDs are computed as hash from string so there is a risk of collisions. Use only when MyStringId is
            not sufficient (eg. sending over network). Because the odds of collision get higher the more hashes are in use, do not use this for
            generated strings and make sure hashes are computed deterministically (eg. at startup) and don't require lengthy gameplay. This way
            we know about any collision early and not from rare and random crash reports.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyStringHash.TryGet(System.Int32)">
            <summary>
            Think HARD before using this. Usually you should be able to use MyStringHash as it is without conversion to int.
            </summary>
        </member>
        <member name="T:VRage.Utils.MyStringId">
            <summary>
            Generates unique IDs for strings. When used as key for hash tables (Dictionary or HashSet)
            always pass in MyStringId.Comparer, otherwise lookups will allocate memory! Never serialize to network or disk!
            
            IDs are created sequentially as they get requested so two IDs might be different between sessions or clients and
            server. You can safely use ToString() as it will not allocate.
            </summary>
        </member>
        <member name="T:VRage.Utils.MyUtils">
            <summary>
            MyFileSystemUtils
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.CreateFolder(System.String)">
            <summary>
            Vytvori zadany adresar. Automaticky povytvara celu adresarovu strukturu, teda ak chcem vytvorit c:\volaco\opica
            a c:\volaco zatial neexistuje, tak tato metoda ho vytvori.
            </summary>
            <param name="folderPath"></param>
        </member>
        <member name="M:VRage.Utils.MyUtils.GenerateQuad(VRageMath.MyQuadD@,VRageMath.Vector3D@,System.Single,System.Single,VRageMath.MatrixD@)">
            <summary>
            Generate oriented quad by matrix
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetAngleBetweenVectors(VRageMath.Vector3,VRageMath.Vector3)">
            <summary>
            Calculating the Angle between two Vectors (return in radians).
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetBillboardQuadOriented(VRageMath.MyQuadD@,VRageMath.Vector3D@,System.Single,System.Single,VRageMath.Vector3@,VRageMath.Vector3@)">
            <summary>
            This billboard isn't facing the camera. It's always oriented in specified direction. May be used as thrusts, or inner light of reflector.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetEdgeSphereCollision(VRageMath.Vector3D@,System.Single,VRageRender.MyTriangle_Vertexes@)">
            <summary>
            Returns intersection point between sphere and its edges. But only if there is intersection between sphere and one of the edges.
            If sphere intersects somewhere inside the triangle, this method will not detect it.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetInsidePolygonForSphereCollision(VRageMath.Vector3D@,VRageRender.MyTriangle_Vertexes@)">
            <summary>
            Return true if point is inside the triangle.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetInsidePolygonForSphereCollision(VRageMath.Vector3@,VRageRender.MyTriangle_Vertexes@)">
            <summary>
            Return true if point is inside the triangle.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetLargestDistanceToSphere(VRageMath.Vector3D@,VRageMath.BoundingSphereD@)">
            <summary>
            Distance between "from" and opposite side of the "sphere". Always positive.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetLineBoundingBoxIntersection(VRageMath.Line@,VRageMath.BoundingBox@)">
            <summary>
            Calculates intersection between line and bounding box and if found, distance is returned. Otherwise null is returned.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetLineTriangleIntersection(VRageMath.Line@,VRageRender.MyTriangle_Vertexes@)">
             <summary>
             Checks whether a ray intersects a triangleVertexes. This uses the algorithm
             developed by Tomas Moller and Ben Trumbore, which was published in the
             Journal of Graphics Tools, pitch 2, "Fast, Minimum Storage Ray-Triangle
             Intersection".
            
             This method is implemented using the pass-by-reference versions of the
             XNA math functions. Using these overloads is generally not recommended,
             because they make the code less readable than the normal pass-by-value
             versions. This method can be called very frequently in a tight inner loop,
             however, so in this particular case the performance benefits from passing
             everything by reference outweigh the loss of readability.
             </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetSmallestDistanceToSphere(VRageMath.Vector3D@,VRageMath.BoundingSphereD@)">
            <summary>
            Calculates distance from point 'from' to boundary of 'sphere'. If point is inside the sphere, distance will be negative.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetSpherePlaneIntersection(VRageMath.BoundingSphereD@,VRageMath.PlaneD@,System.Double@)">
            <summary>
            This tells if a sphere is BEHIND, in FRONT, or INTERSECTS a plane, also it's distance
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetSpherePlaneIntersection(VRageMath.BoundingSphereD@,VRage.Utils.MyPlane@,System.Single@)">
            <summary>
            This tells if a sphere is BEHIND, in FRONT, or INTERSECTS a plane, also it's distance
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetSphereTriangleIntersection(VRageMath.BoundingSphereD@,VRage.Utils.MyPlane@,VRageRender.MyTriangle_Vertexes@)">
            <summary>
            Method returns intersection point between sphere and triangle (which is defined by vertexes and plane).
            If no intersection found, method returns null.
            See below how intersection point can be calculated, because it's not so easy - for example sphere vs. triangle will 
            hardly generate just intersection point... more like intersection area or something.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetSphereTriangleIntersection(VRageMath.BoundingSphereD@,VRageMath.PlaneD@,VRageRender.MyTriangle_Vertexes@)">
            <summary>
            Method returns intersection point between sphere and triangle (which is defined by vertexes and plane).
            If no intersection found, method returns null.
            See below how intersection point can be calculated, because it's not so easy - for example sphere vs. triangle will 
            hardly generate just intersection point... more like intersection area or something.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.IsLineIntersectingBoundingSphere(VRageMath.LineD@,VRageMath.BoundingSphereD@)">
            <summary>
            Check intersection between line and bounding sphere
            We don't use BoundingSphere.Contains(Ray ...) because ray doesn't have an end, but line does, so we need
            to check if line really intersects the sphere.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.Normalize(VRageMath.Vector3)">
            <summary>
            Protected normalize with assert
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.MyUtils.Normalize(VRageMath.Vector3@,VRageMath.Vector3@)">
            <summary>
            Protected normalize with assert
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.MyUtils.Normalize(VRageMath.Matrix@,VRageMath.Matrix@)">
            <summary>
            Protected normalize with assert
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.MyUtils.Init``1(``0@)">
            <summary>
            When location is null, creates new instance, stores it in location and returns it.
            When location is not null, returns it.
            </summary>
        </member>
        <member name="F:VRage.Utils.MyUtils.DefaultNumberSuffix">
            <summary>
            Default number suffix, k = thousand, m = million, g/b = billion
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetCoordAligned(VRageMath.Vector2,VRageMath.Vector2,VRage.Utils.MyGuiDrawAlignEnum)">
            <summary>
            Aligns rectangle, works in screen/texture/pixel coordinates, not normalized coordinates.
            </summary>
            <returns>Pixel coordinates for texture.</returns>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetCoordAlignedFromCenter(VRageMath.Vector2,VRageMath.Vector2,VRage.Utils.MyGuiDrawAlignEnum)">
            <summary>
            Modifies input coordinate (in center) using alignment and
            size of the rectangle. Result is at position inside rectangle
            specified by alignment.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetCoordTopLeftFromAligned(VRageMath.Vector2,VRageMath.Vector2,VRage.Utils.MyGuiDrawAlignEnum)">
            <summary>
            Reverses effect of alignment to compute top-left corner coordinate.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetCoordTopLeftFromAligned(VRageMath.Vector2I,VRageMath.Vector2I,VRage.Utils.MyGuiDrawAlignEnum)">
            <summary>
            Reverses effect of alignment to compute top-left corner coordinate.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetCoordCenterFromAligned(VRageMath.Vector2,VRageMath.Vector2,VRage.Utils.MyGuiDrawAlignEnum)">
            <summary>
            Reverses effect of alignment to compute center coordinate.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetCoordAlignedFromRectangle(VRageMath.RectangleF@,VRage.Utils.MyGuiDrawAlignEnum)">
            <summary>
            Returns coordinate within given rectangle specified by draw align. Rectangle position should be
            upper left corner. Conversion assumes that Y coordinates increase downwards.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetRandomVector3">
            <summary>
            Returns a uniformly-distributed random vector from inside of a box (-1,-1,-1), (1, 1, 1)
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetRandomVector3D">
            <summary>
            Returns a uniformly-distributed random vector from inside of a box (-1,-1,-1), (1, 1, 1)
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetRandomTimeSpan(System.TimeSpan,System.TimeSpan)">
            <summary>
            Returns a random TimeSpan between begin (inclusive) and end (exclusive).
            </summary>
        </member>
        <member name="T:VRage.Utils.MyVector3ISet">
            <summary>
            A data structure for a set of Vector3I coordinates optimized for sets with high spatial coherence (hence the name)
            </summary>
        </member>
        <member name="M:VRage.Utils.MyVector3ISet.Union(VRage.Utils.MyVector3ISet)">
            <summary>
            Makes a union of this set and the other set and saves it in this set
            </summary>
        </member>
        <member name="P:VRage.Utils.MyVector3ISet.Timestamp">
            <summary>
            For detection of modification of the set during iteration. Every modifying operation on the set should increase the timestamp
            </summary>
        </member>
        <member name="M:VRage.Utils.My5BitEncoding.#ctor">
            <summary>
            Initializes a new instance of the Encoding5Bit class.
            Uses characters 0-9 and A-Z except (0,O,1,I).
            </summary>
        </member>
        <member name="M:VRage.Utils.My5BitEncoding.#ctor(System.Char[])">
            <summary>
            Initializes a new instance of the Encoding5Bit class.
            </summary>
            <param name="characters">32 characters which will be used when encoding bytes to string.</param>
        </member>
        <member name="M:VRage.Utils.My5BitEncoding.Encode(System.Byte[])">
            <summary>
            Encodes data as 5bit string.
            </summary>
        </member>
        <member name="M:VRage.Utils.My5BitEncoding.Decode(System.Char[])">
            <summary>
            Decodes 5bit string as bytes, not alligned characters may be lost.
            Only decode strings encoded with Encode.
            </summary>
            <param name="encoded5BitText"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.MyDebug.AssertRelease(System.Boolean)">
            <summary>
            This "assert" is executed in DEBUG and RELEASE modes. Use it in code that that won't suffer from more work (e.g. loading), not in frequently used loops
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:VRage.Utils.MyDebug.AssertRelease(System.Boolean,System.String)">
            <summary>
            This "assert" is executed in DEBUG and RELEASE modes. Use it in code that that won't suffer from more work (e.g. loading), not in frequently used loops
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:VRage.Utils.MyDebug.FailRelease(System.String)">
            <summary>
            Logs the message on release and also displays a message on DEBUG.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:VRage.Utils.MyDebug.AssertDebug(System.Boolean)">
            <summary>
            This "assert" is executed in DEBUG mode. Because people dont know how to use AssertRelease!
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:VRage.Utils.MyDebug.AssertDebug(System.Boolean,System.String)">
            <summary>
            This "assert" is executed in DEBUG mode. Because people dont know how to use AssertRelease!
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:VRage.Utils.MyDebug.IsValid(System.Single)">
            <summary>
            Returns true if float is valid
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.MyDebug.IsValid(VRageMath.Vector3)">
            <summary>
            Returns true if Vector3 is valid
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.MyDebug.IsValid(VRageMath.Vector2)">
            <summary>
            Returns true if Vector2 is valid
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.MyDebug.IsValid(System.Nullable{VRageMath.Vector3})">
            <summary>
            Returns true if Vector3 is valid
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.MyDebug.AssertIsValid(VRageMath.Vector3)">
            <summary>
            Returns true if Vector3 is valid
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.MyDebug.AssertIsValid(System.Nullable{VRageMath.Vector3})">
            <summary>
            Returns true if Vector3 is valid
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.MyDebug.AssertIsValid(VRageMath.Vector2)">
            <summary>
            Returns true if Vector2 is valid
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.MyDebug.AssertIsValid(System.Single)">
            <summary>
            Returns true if float is valid
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="T:VRage.Utils.MyEventSet">
            <summary>
            From http://www.wintellect.com/Resources CLR Via C# by Jeffrey Richter
            </summary>
        </member>
        <member name="T:VRage.Utils.MyMessageBox">
            <summary>
            Custom message box
            </summary>
        </member>
        <member name="M:VRage.Utils.MyEnumDuplicitiesTester.GetCompanyNameOfAssembly(System.Reflection.Assembly)">
            <summary>
            The company name of the calling assembly.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyWingedEdgeMesh.Copy">
            <summary>
            For testing purposes only! The copy is only a shallow copy (i.e. userdata is not copied)
            </summary>
        </member>
        <member name="M:VRage.Utils.MyWingedEdgeMesh.MakeEdgeFace(System.Int32,System.Int32,System.Int32,System.Int32,System.Object,System.Int32@)">
            <summary>
            Creates a new face by closing the gap between vertices vert1 and vert2 by a new edge
            </summary>
            <param name="vert1">Point that will be shared by the new edge and edge1</param>
            <param name="vert2">Point that will be shared by the new edge and edge2</param>
            <param name="edge1">Predecessor of the new edge</param>
            <param name="edge2">Successor of the new edge</param>
            <param name="faceUserData">User data for the newly created face</param>
        </member>
        <member name="M:VRage.Utils.MyWingedEdgeMesh.MergeEdges(System.Int32,System.Int32)">
            <summary>
            Merges two edges together into one. These edges have to border on the edge of the mesh (i.e. face -1)
            Note that this also merges the corresponding vertices!
            </summary>
            <param name="edge1">The edge that will be merged</param>
            <param name="edge2">The edge that will be kept</param>
        </member>
        <member name="M:VRage.Utils.MyWingedEdgeMesh.ExtrudeTriangleFromEdge(VRageMath.Vector3@,System.Int32,System.Object,System.Int32@,System.Int32@)">
            <summary>
            Creates a new triangle by adding a vertex to an existing edge
            </summary>
            <param name="newVertex">Position of the new vertex</param>
            <param name="edge">The edge from which we want to extrude</param>
            <param name="faceUserData">User data that will be saved in the face</param>
            <param name="newEdgeS">Index of the new edge that follows edge "edge" in the new triangle.</param>
            <param name="newEdgeP">Index of the new edge that precedes edge "edge" in the new triangle.</param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.MyWingedEdgeMesh.MakeFace(System.Object,System.Int32)">
            <summary>
            Makes a face by filling in the empty edge loop incident to incidentEdge
            </summary>
            <param name="userData"></param>
            <param name="incidentEdge"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.MyWingedEdgeMesh.SortFreeFaces">
            <summary>
            Sorts the list of free faces. This ensures that subsequent face allocations will return increasing sequence of face indices,
            unless interrupted by face deallocation. This can be useful in some algorithms that rely on ordering of the face indices.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyWingedEdgeMesh.CheckFreeEntryConsistency">
            <summary>
            Checks for loops in the meshe's tables' freed entries
            </summary>
        </member>
        <member name="M:VRage.Utils.MyWingedEdgeMesh.EdgeTableEntry.TryGetSharedVertex(VRage.Utils.MyWingedEdgeMesh.EdgeTableEntry@)">
            <summary>
            Returns -1 if there is no shared edge
            </summary>
        </member>
        <member name="M:VRage.Utils.MyWingedEdgeMesh.EdgeTableEntry.VertexLeftFace(System.Int32)">
            <summary>
            Returns a face to the left when going towards the given vertex
            </summary>
        </member>
        <member name="M:VRage.Utils.MyWingedEdgeMesh.EdgeTableEntry.VertexRightFace(System.Int32)">
            <summary>
            Returns a face to the right when going towards the given vertex
            </summary>
        </member>
        <member name="M:VRage.Utils.MyWingedEdgeMesh.EdgeTableEntry.FaceSucc(System.Int32)">
            <summary>
            Returns the successor of this edge in the given face
            </summary>
        </member>
        <member name="M:VRage.Utils.MyWingedEdgeMesh.EdgeTableEntry.SetFaceSucc(System.Int32,System.Int32)">
            <summary>
            Sets the successor of this edge in the given face
            </summary>
        </member>
        <member name="M:VRage.Utils.MyWingedEdgeMesh.EdgeTableEntry.FacePred(System.Int32)">
            <summary>
            Returns the predecessor of this edge in the given face
            </summary>
        </member>
        <member name="M:VRage.Utils.MyWingedEdgeMesh.EdgeTableEntry.SetFacePred(System.Int32,System.Int32)">
            <summary>
            Sets the predecessor of this edge in the given face
            </summary>
        </member>
        <member name="M:VRage.Utils.MyWingedEdgeMesh.EdgeTableEntry.VertexSucc(System.Int32)">
            <summary>
            Gets the successor around the given vertex.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyWingedEdgeMesh.EdgeTableEntry.SetVertexSucc(System.Int32,System.Int32)">
            <summary>
            Sets the successor around the given vertex.
            </summary>
            <returns>The old successor value</returns>
        </member>
        <member name="M:VRage.Utils.MyWingedEdgeMesh.EdgeTableEntry.VertexPred(System.Int32)">
            <summary>
            Gets the predecessor around the given vertex
            </summary>
        </member>
        <member name="M:VRage.Utils.MyWingedEdgeMesh.EdgeTableEntry.SetVertexPred(System.Int32,System.Int32)">
            <summary>
            Sets the predecessor around the given vertex.
            </summary>
            <returns>The old predecessor value</returns>
        </member>
        <member name="P:VRage.Utils.MyWingedEdgeMesh.EdgeTableEntry.NextFreeEntry">
            <summary>
            Only valid for empty (deallocated) table entries. In that case, it points to the next free table entry.
            If this is -1, this entry is the last free entry.
            </summary>
        </member>
        <member name="P:VRage.Utils.MyWingedEdgeMesh.VertexTableEntry.NextFreeEntry">
            <summary>
            Only valid for empty (deallocated) table entries. In that case, it points to the next free table entry.
            If this is -1, this entry is the last free entry.
            </summary>
        </member>
        <member name="P:VRage.Utils.MyWingedEdgeMesh.FaceTableEntry.NextFreeEntry">
            <summary>
            Only valid for empty (deallocated) table entries. In that case, it points to the next free table entry.
            If this is -1, this entry is the last free entry.
            </summary>
        </member>
        <member name="T:VRage.Utils.MyWingedEdgeMesh.Edge">
            <summary>
            Note: This is invalid after the mesh changes!
            </summary>
        </member>
        <member name="T:VRage.Utils.MyWingedEdgeMesh.Face">
            <summary>
            Note: This is invalid after the mesh changes!
            </summary>
        </member>
        <member name="T:VRage.Utils.MyWingedEdgeMesh.FaceEdgeEnumerator">
            <summary>
            Note: This is invalid after the mesh changes!
            </summary>
        </member>
        <member name="T:VRage.Utils.MyWingedEdgeMesh.FaceVertexEnumerator">
            <summary>
            Note: This is invalid after the mesh changes!
            </summary>
        </member>
        <member name="T:VRage.Utils.MyWingedEdgeMesh.EdgeEnumerator">
            <summary>
            Note: This is invalid after the mesh changes!
            </summary>
        </member>
        <member name="T:VRage.Utils.MyBBSetSampler">
            <summary>
            This class allows for uniform generation of points from a set of bounding boxes.
            
            You start by constructing a bounding box from where the points will be sampled.
            Then you can incrementally subtract bounding boxes and the resulting structure will allow you
            to generate uniformly distributed points using the Sample() function.
            </summary>
        </member>
        <member name="F:VRage.Voxels.MyCellCoord.Lod">
            <summary>
            0 is the most detailed.
            </summary>
        </member>
        <member name="M:VRage.Voxels.MyClipmap.InvalidateRange(VRageMath.Vector3I,VRageMath.Vector3I)">
            <param name="minCellLod0">Inclusive.</param>
            <param name="maxCellLod0">Inclusive.</param>
        </member>
        <member name="M:VRage.Voxels.MyClipmap.LodLevel.WasAncestorCellLoaded(VRage.Voxels.MyClipmap.LodLevel,VRage.Voxels.MyCellCoord@)">
            <summary>
            Checks ancestor nodes recursively.
            </summary>
        </member>
        <member name="M:VRage.Voxels.MyClipmap.LodLevel.ChildrenWereLoaded(VRage.Voxels.MyClipmap.LodLevel,VRage.Voxels.MyCellCoord@)">
            <summary>
            Checks only immediate children (any deeper would take too long).
            </summary>
        </member>
        <member name="M:VRage.Voxels.MyStorageData.Resize(VRageMath.Vector3I,VRageMath.Vector3I)">
            <param name="start">Inclusive.</param>
            <param name="end">Inclusive.</param>
        </member>
        <member name="T:VRage.Voxels.MyVoxelCoordSystems">
            <summary>
            Functions for transforming to and from various coordinate systems in voxel maps and for computing bounding boxes of various types of cells.
            Note that local and world positions are (and should be) always in the min-corner!
            </summary>
        </member>
    </members>
</doc>
